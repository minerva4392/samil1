<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>간단한 리듬 게임</title>
    <!-- Tailwind CSS CDN -->
    <script src="https://cdn.tailwindcss.com"></script>
    <!-- Tone.js CDN for audio -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/tone/14.8.49/Tone.min.js"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
    <style>
        /* 기본 바디 스타일: 폰트, 배경색, 중앙 정렬, 최소 높이 설정 */
        body {
            font-family: 'Inter', sans-serif;
            background-color: #1a202c; /* 어두운 배경 */
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            margin: 0;
            overflow: hidden; /* 스크롤 방지 */
        }
        /* 게임 컨테이너 스타일: 위치, 최대 너비/높이, 배경색, 그림자, 패딩 등 */
        .game-container {
            position: relative;
            width: 100%;
            max-width: 600px; /* 게임 영역 최대 너비 */
            height: 80vh; /* 반응형 높이 */
            max-height: 800px; /* 게임 영역 최대 높이 */
            background-color: #2d3748; /* 게임 영역용 더 어두운 배경 */
            border-radius: 1rem;
            box-shadow: 0 10px 15px rgba(0, 0, 0, 0.5);
            overflow: hidden; /* 노트가 밖으로 나가지 않도록 클립 */
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 1rem;
            box-sizing: border-box;
        }
        /* 캔버스 스타일: 배경색, 테두리, 너비/높이, 그림자 */
        canvas {
            background-color: #1a202c; /* 캔버스 배경 */
            border-radius: 0.5rem;
            width: 100%; /* 컨테이너 너비에 맞춤 */
            height: calc(100% - 180px); /* 점수/정보 및 난이도 영역 + 키 피드백을 위한 높이 조정 */
            margin-bottom: 1rem;
            box-shadow: inset 0 0 10px rgba(0, 0, 0, 0.3);
        }
        /* 게임 정보 표시 영역 스타일 */
        .game-info {
            width: 100%;
            display: flex;
            justify-content: space-between;
            align-items: center;
            color: #e2e8f0; /* 밝은 텍스트 */
            font-size: 1.25rem;
            font-weight: bold;
            padding: 0 1rem;
            box-sizing: border-box;
            height: 80px; /* 정보 영역 고정 높이 */
        }
        /* 난이도 선택 버튼 컨테이너 스타일 */
        .difficulty-selection {
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }
        /* 난이도 버튼 기본 스타일 */
        .difficulty-button {
            background-color: #4a5568; /* 회색 버튼 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            font-size: 1rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        /* 난이도 버튼 호버 효과 */
        .difficulty-button:hover {
            background-color: #636b7d;
            transform: translateY(-1px);
        }
        /* 선택된 난이도 버튼 스타일 */
        .difficulty-button.selected {
            background-image: linear-gradient(to right, #63b3ed, #4299e1);
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.4);
        }
        /* 게임 시작 버튼 스타일 */
        .start-button {
            background-image: linear-gradient(to right, #63b3ed, #4299e1);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 9999px; /* 완전히 둥근 모서리 */
            font-size: 1.25rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        /* 시작 버튼 호버 효과 */
        .start-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        /* 시작 버튼 클릭 시 효과 */
        .start-button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
        /* 메시지 박스 기본 스타일 (게임 종료 메시지, 카운트다운 등) */
        .message-box {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background-color: rgba(0, 0, 0, 0.8);
            color: white;
            padding: 2rem;
            border-radius: 1rem;
            text-align: center;
            font-size: 1.5rem;
            font-weight: bold;
            z-index: 100;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.6);
            display: none; /* 기본적으로 숨김 */
        }
        /* 메시지 박스 내 버튼 스타일 */
        .message-box button {
            margin-top: 1rem;
            background-color: #48bb78; /* 녹색 버튼 */
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 0.5rem;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            transition: background-color 0.2s;
        }
        /* 메시지 박스 버튼 호버 효과 */
        .message-box button:hover {
            background-color: #38a169;
        }
        /* 콤보 팝업 스타일 */
        #comboPopup {
            position: absolute;
            top: 40%; /* 중앙보다 약간 위로 위치 */
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 3rem; /* 큰 글꼴로 임팩트 */
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 255, 255, 0.7), 0 0 20px rgba(255, 255, 255, 0.5);
            opacity: 0; /* 초기에는 숨김 */
            transition: opacity 0.5s ease-out; /* 부드러운 페이드 아웃 */
            pointer-events: none; /* 클릭이 통과하도록 허용 */
            z-index: 90; /* 메시지 박스 아래, 게임 요소 위 */
        }
        /* 일시정지 메뉴 특정 스타일 */
        #pauseMenu {
            display: none; /* 기본적으로 숨김 */
            flex-direction: column;
            gap: 1rem;
            padding: 2rem;
            background-color: rgba(45, 55, 72, 0.95); /* 약간 투명한 어두운 배경 */
            border: 2px solid #63b3ed;
            box-shadow: 0 0 20px rgba(99, 179, 237, 0.5); /* 파란색 발광 효과 */
        }
        #pauseMenu p {
            font-size: 2rem;
            margin-bottom: 1rem;
            color: #e2e8f0;
        }
        #pauseMenu button {
            background-image: linear-gradient(to right, #4299e1, #63b3ed);
            color: white;
            padding: 0.75rem 1.5rem;
            border-radius: 0.75rem;
            font-size: 1.2rem;
            font-weight: bold;
            cursor: pointer;
            border: none;
            outline: none;
            transition: all 0.2s ease-in-out;
            box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }
        #pauseMenu button:hover {
            transform: translateY(-2px);
            box-shadow: 0 6px 8px rgba(0, 0, 0, 0.4);
        }
        #pauseMenu button:active {
            transform: translateY(0);
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-info">
            <div id="scoreDisplay">점수: 0</div>
            <div id="healthDisplay">체력: 100</div>
            <div id="comboDisplay">콤보: 0</div>
        </div>
        <div class="difficulty-selection">
            <button id="easyModeBtn" class="difficulty-button">이지</button>
            <button id="normalModeBtn" class="difficulty-button selected">노말</button>
            <button id="hardModeBtn" class="difficulty-button">하드</button>
            <button id="impossibleModeBtn" class="difficulty-button">불가능</button>
        </div>
        <canvas id="gameCanvas"></canvas>
        <button id="startButton" class="start-button">게임 시작</button>
        <div id="comboPopup"></div> <!-- 콤보 팝업 요소 -->
    </div>

    <div id="messageBox" class="message-box">
        <p id="messageText"></p>
        <button id="messageBoxOkButton">확인</button>
    </div>

    <div id="pauseMenu" class="message-box">
        <p>게임 일시정지</p>
        <button id="resumeGameBtn">게임 계속</button>
        <button id="resetGameBtn">게임 초기화</button>
        <button id="exitGameBtn">게임 종료</button>
    </div>

    <!-- 카운트다운 표시를 위한 새로운 요소 -->
    <div id="countdownDisplay" class="message-box" style="font-size: 5rem; color: #63b3ed;"></div>

    <script>
        // 게임 상수 (계산을 위한 참조 값, 그리기 위한 고정 픽셀 값 아님)
        const REFERENCE_LANE_COUNT = 4;
        const REFERENCE_NOTE_SIZE = 90; // 단일 노트의 참조 크기
        const REFERENCE_HIT_ZONE_OFFSET_Y = 20; // 히트 존의 하단 오프셋 참조
        const REFERENCE_CANVAS_HEIGHT_FOR_SCALING = 600; // 속도 및 허용 오차 스케일링을 위한 참조 캔버스 높이

        // 롱 노트 특정 상수 (REFERENCE_NOTE_SIZE 기반)
        const LONG_NOTE_CHANCE = 0.2; // 롱 노트가 나올 확률 20%
        const REFERENCE_LONG_NOTE_LENGTHS = [
            REFERENCE_NOTE_SIZE * 2, // 짧은 롱 노트 (일반 노트 높이의 2배)
            REFERENCE_NOTE_SIZE * 3, // 중간 롱 노트 (일반 노트 높이의 3배)
            REFERENCE_NOTE_SIZE * 4  // 긴 롱 노트 (일반 노트 높이의 4배)
        ];
        const LONG_NOTE_HOLD_SCORE = 150; // 롱 노트 홀드 완료 시 추가 점수
        const LONG_NOTE_HOLD_TICK_INTERVAL = 500; // 0.5초 (밀리초)
        const LONG_NOTE_HOLD_SCORE_PER_TICK = 50; // 0.5초 홀드당 점수
        const LONG_NOTE_HOLD_COMBO_PER_TICK = 1; // 0.5초 홀드당 콤보

        // 참조 판정 허용 오차 (동적으로 스케일링됨)
        const REFERENCE_REGULAR_NOTE_TOLERANCE = 60;
        const REFERENCE_LONG_NOTE_TOLERANCE_2X = 90;
        const REFERENCE_LONG_NOTE_TOLERANCE_3X = 120;
        const REFERENCE_LONG_NOTE_TOLERANCE_4X = 220;

        const HEALTH_ON_MISS = 5; // 노트 놓쳤을 때 감소하는 체력

        // 난이도에 따른 빈 키 입력/미스 시 점수 페널티
        const SCORE_PENALTIES_ON_EMPTY_PRESS = {
            'easy': 10,
            'normal': 20,
            'hard': 50,
            'impossible': 100
        };

        const CORNER_RADIUS_RATIO = 0.08; // 반응성을 위한 노트 크기 대비 모서리 반경 비율

        // 난이도 설정 (noteSpeed와 spawnInterval은 상대적인 값이며 스케일링됨)
        const DIFFICULTY_SETTINGS = {
            'easy': {
                noteSpeed: 3,
                noteSpawnInterval: 700,
                name: '이지'
            },
            'normal': {
                noteSpeed: 5,
                noteSpawnInterval: 500,
                name: '노말'
            },
            'hard': {
                noteSpeed: 7,
                noteSpawnInterval: 300,
                name: '하드'
            },
            'impossible': {
                noteSpeed: 9,
                noteSpawnInterval: 150,
                name: '불가능'
            }
        };

        // 게임 상태 변수
        let canvas, ctx;
        let score = 0;
        let health = 100;
        let combo = 0;
        let maxCombo = 0;
        let notes = [];
        let gameRunning = false;
        let animationFrameId;
        let lastNoteTime = 0;
        let currentDifficulty = 'normal';
        let pressedKeys = {};
        let comboPopup;
        let pauseMenuElement; // 일시정지 메뉴 요소 참조
        let countdownDisplayElement; // 카운트다운 표시 요소 참조

        // 일시정지/재개 관련 변수
        let isPaused = false;
        let gameStartTime = 0; // 게임이 실제로 시작(또는 재개)된 타임스탬프
        let totalPausedTime = 0; // 게임이 일시정지된 총 시간 누적
        let currentPauseStartTime = 0; // 현재 일시정지가 시작된 시간

        // 동적 속성 (현재 캔버스 크기에 따라 계산됨)
        let LANE_SPACING, NOTE_SIZE, NOTE_WIDTH, NOTE_HEIGHT, HIT_ZONE_HEIGHT, HIT_ZONE_Y, CORNER_RADIUS;
        let REGULAR_NOTE_TOLERANCE, LONG_NOTE_TOLERANCE_2X, LONG_NOTE_TOLERANCE_3X, LONG_NOTE_TOLERANCE_4X;
        let LONG_NOTE_LENGTHS_DYNAMIC = []; // 롱 노트를 위한 동적 길이

        const KEY_MAP = {
            'd': 0,
            'f': 1,
            'j': 2,
            'k': 3
        };
        const LANE_KEYS = ['D', 'F', 'J', 'K'];
        const LANE_COLORS = ['#ef4444', '#f97316', '#eab308', '#22c55e'];
        const PRESSED_DARKER_COLOR_TOP = '#1a202c';
        const PRESSED_DARKER_COLOR_BOTTOM = '#000000';

        const GAME_DURATION_MS = (4 * 60 + 11) * 1000; // 게임 지속 시간 (4분 11초)
        let gameTimeoutId;

        let synth, kick, hihat;
        let bgmPart;

        // 오디오 초기화 함수 (Tone.js 사용)
        async function initializeAudio() {
            synth = new Tone.PolySynth(Tone.Synth, {
                oscillator: { type: "sine" },
                envelope: { attack: 0.005, decay: 0.1, sustain: 0.05, release: 0.2 },
            }).toDestination();
            kick = new Tone.MembraneSynth({
                pitchDecay: 0.05,
                octaves: 10,
                envelope: { attack: 0.001, decay: 0.4, sustain: 0.01, release: 0.8 },
            }).toDestination();
            hihat = new Tone.NoiseSynth({
                noise: { type: "white" },
                envelope: { attack: 0.001, decay: 0.05, sustain: 0.01, release: 0.05 },
            }).toDestination();

            // bgmPart 정의
            bgmPart = new Tone.Sequence((time, note) => {
                if (note === 'kick') {
                    kick.triggerAttackRelease("C1", "8n", time);
                } else if (note === 'hihat') {
                    hihat.triggerAttackRelease("16n", time);
                }
            }, [
                ['kick', 'hihat', 'hihat', 'hihat'],
                ['hihat', 'hihat', 'hihat', 'hihat'],
                ['kick', 'hihat', 'hihat', 'hihat'],
                ['hihat', 'hihat', 'hihat', 'hihat']
            ], "8n"); // .start(0)는 startGame()에서 호출

            Tone.Transport.bpm.value = 120;
            Tone.Transport.loop = true;
            Tone.Transport.loopEnd = '2m';
        }

        // 메시지 박스 표시 함수
        function showMessageBox(message, onOk = null) {
            const messageBox = document.getElementById('messageBox');
            const messageText = document.getElementById('messageText');
            const messageBoxOkButton = document.getElementById('messageBoxOkButton');

            messageText.textContent = message;
            messageBox.style.display = 'block';

            messageBoxOkButton.onclick = () => {
                messageBox.style.display = 'none';
                if (onOk) {
                    onOk();
                }
            };
        }

        // 콤보 팝업 표시 함수
        function displayComboPopup(currentCombo) {
            comboPopup.textContent = `${currentCombo} COMBO!`;
            comboPopup.style.opacity = '1';
            setTimeout(() => {
                comboPopup.style.opacity = '0';
            }, 1000);
        }

        // 난이도 설정 함수
        function setDifficulty(difficulty) {
            currentDifficulty = difficulty;
            document.querySelectorAll('.difficulty-button').forEach(button => {
                button.classList.remove('selected');
            });
            document.getElementById(`${difficulty}ModeBtn`).classList.add('selected');
        }

        // 윈도우 로드 시 초기화
        window.onload = async function() {
            canvas = document.getElementById('gameCanvas');
            ctx = canvas.getContext('2d');
            comboPopup = document.getElementById('comboPopup');
            pauseMenuElement = document.getElementById('pauseMenu');
            countdownDisplayElement = document.getElementById('countdownDisplay');

            resizeCanvas(); // 초기 캔버스 크기 조정 및 동적 상수 계산
            window.addEventListener('resize', resizeCanvas); // 캔버스 반응형 조정

            await initializeAudio(); // 오디오 초기화

            document.getElementById('startButton').addEventListener('click', startGame);
            document.addEventListener('keydown', handleKeyPress);
            document.addEventListener('keyup', handleKeyRelease);
            document.addEventListener('keydown', handleGlobalKeyPress); // ESC 키와 같은 전역 키 처리

            // 일시정지 메뉴 버튼 리스너
            document.getElementById('resumeGameBtn').addEventListener('click', resumeGame);
            // 리셋 버튼은 카운트다운을 트리거하도록 수정
            document.getElementById('resetGameBtn').addEventListener('click', () => {
                resetGameState(); // 게임 오버 메시지 없이 게임 상태 초기화
                startCountdown(); // 카운트다운 시작 후 게임 시작
            });
            document.getElementById('exitGameBtn').addEventListener('click', endGame);


            for (let i = 0; i < REFERENCE_LANE_COUNT; i++) {
                pressedKeys[i] = false;
            }

            document.getElementById('easyModeBtn').addEventListener('click', () => setDifficulty('easy'));
            document.getElementById('normalModeBtn').addEventListener('click', () => setDifficulty('normal'));
            document.getElementById('hardModeBtn').addEventListener('click', () => setDifficulty('hard'));
            document.getElementById('impossibleModeBtn').addEventListener('click', () => setDifficulty('impossible'));

            setDifficulty('normal'); // 기본 난이도 설정

            showMessageBox("게임 시작 버튼을 눌러주세요!\n\n키보드 'D', 'F', 'J', 'K' 키로 노트를 맞춰보세요.", () => {});
        };

        // 현재 캔버스 크기에 따라 동적 게임 상수 계산
        function calculateDynamicConstants() {
            LANE_SPACING = canvas.width / REFERENCE_LANE_COUNT;
            // 너비 비율에 따라 10px 간격 스케일링, 최소 간격 보장
            const scaledGap = 10 * (canvas.width / 400);
            NOTE_SIZE = LANE_SPACING - Math.max(5, scaledGap); 
            NOTE_WIDTH = NOTE_SIZE;
            NOTE_HEIGHT = NOTE_SIZE; // 일반 노트는 정사각형
            HIT_ZONE_HEIGHT = NOTE_SIZE;
            // 높이 비율에 따라 하단 오프셋 스케일링
            HIT_ZONE_Y = canvas.height - HIT_ZONE_HEIGHT - (REFERENCE_HIT_ZONE_OFFSET_Y * (canvas.height / REFERENCE_CANVAS_HEIGHT_FOR_SCALING));
            CORNER_RADIUS = NOTE_SIZE * CORNER_RADIUS_RATIO;

            // 높이 비율에 따라 판정 허용 오차 스케일링
            const heightRatio = canvas.height / REFERENCE_CANVAS_HEIGHT_FOR_SCALING;
            REGULAR_NOTE_TOLERANCE = REFERENCE_REGULAR_NOTE_TOLERANCE * heightRatio;
            LONG_NOTE_TOLERANCE_2X = REFERENCE_LONG_NOTE_TOLERANCE_2X * heightRatio;
            LONG_NOTE_TOLERANCE_3X = REFERENCE_LONG_NOTE_TOLERANCE_3X * heightRatio;
            LONG_NOTE_TOLERANCE_4X = REFERENCE_LONG_NOTE_TOLERANCE_4X * heightRatio;

            // 높이 비율에 따라 롱 노트 길이 스케일링
            LONG_NOTE_LENGTHS_DYNAMIC = REFERENCE_LONG_NOTE_LENGTHS.map(len => len * heightRatio);
        }

        // 캔버스 크기 조정 함수
        function resizeCanvas() {
            const container = canvas.parentElement;
            canvas.width = container.clientWidth;
            canvas.height = container.clientHeight;
            calculateDynamicConstants(); // 크기 조정 시 모든 동적 상수 재계산
        }

        // 게임 상태를 초기화하고 게임 오버 메시지를 표시하지 않는 함수
        function resetGameState() {
            score = 0;
            health = 100;
            combo = 0;
            maxCombo = 0;
            notes = [];
            isPaused = false; // 일시정지 상태 아님
            totalPausedTime = 0; // 총 일시정지 시간 초기화
            currentPauseStartTime = 0; // 현재 일시정지 시작 시간 초기화
            gameRunning = false; // 게임 루프 중지

            // 디스플레이 업데이트
            document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
            document.getElementById('healthDisplay').textContent = `체력: ${health}`;
            document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;

            // 표시될 수 있는 모든 게임 관련 UI 요소 숨기기
            document.getElementById('startButton').style.display = 'block'; // 다음 게임을 위해 시작 버튼 표시
            document.querySelector('.difficulty-selection').style.display = 'flex'; // 난이도 버튼 표시
            pauseMenuElement.style.display = 'none'; // 일시정지 메뉴 숨기기
            countdownDisplayElement.style.display = 'none'; // 카운트다운 숨기기
            comboPopup.style.opacity = '0'; // 콤보 팝업 숨기기

            // 보류 중인 애니메이션 프레임 또는 타임아웃 지우기
            cancelAnimationFrame(animationFrameId);
            Tone.Transport.stop();
            bgmPart.stop(); // 시퀀스 명시적으로 중지
            clearTimeout(gameTimeoutId);

            // 눌린 키 시각적 상태 초기화
            for (let i = 0; i < REFERENCE_LANE_COUNT; i++) {
                pressedKeys[i] = false;
            }
        }

        // 게임 시작 함수
        async function startGame() {
            if (gameRunning) return; // 게임이 이미 실행 중이면 아무것도 하지 않음

            // 오디오 컨텍스트가 일시 중단된 경우 재개 (첫 사용자 상호 작용 시 일반적)
            if (Tone.context.state !== 'running') {
                await Tone.context.resume();
            }

            resetGameState(); // 시작하기 전에 깨끗한 상태 보장

            gameRunning = true;
            gameStartTime = performance.now(); // 실제 게임 시작 시간 기록

            document.getElementById('startButton').style.display = 'none';
            document.querySelector('.difficulty-selection').style.display = 'none';
            
            bgmPart.start(0); // 배경 음악 시퀀스를 처음부터 시작
            Tone.Transport.start(); // 배경 음악 트랜스포트 시작
            lastNoteTime = performance.now(); // 마지막 노트 생성 시간 초기화
            gameLoop(); // 게임 루프 시작

            // 게임 지속 시간 동안 타임아웃 설정
            gameTimeoutId = setTimeout(endGame, GAME_DURATION_MS);
        }

        // 3초 카운트다운 시작 함수
        function startCountdown() {
            pauseMenuElement.style.display = 'none'; // 일시정지 메뉴 숨기기
            countdownDisplayElement.style.display = 'flex'; // 카운트다운 표시

            let countdownValue = 3;
            countdownDisplayElement.textContent = countdownValue;

            const countdownInterval = setInterval(() => {
                countdownValue--;
                if (countdownValue > 0) {
                    countdownDisplayElement.textContent = countdownValue;
                } else { // countdownValue가 0이거나 0보다 작은 모든 값을 처리
                    clearInterval(countdownInterval);
                    countdownDisplayElement.style.display = 'none'; // 카운트다운 숨기기
                    startGame(); // 카운트다운 후 게임 시작
                }
            }, 1000);
        }

        // 둥근 사각형 그리기 함수
        function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
            ctx.beginPath();
            ctx.moveTo(x + radius, y);
            ctx.lineTo(x + width - radius, y);
            ctx.quadraticCurveTo(x + width, y, x + width, y + radius);
            ctx.lineTo(x + width, y + height - radius);
            ctx.quadraticCurveTo(x + width, y + height, x + width - radius, y + height);
            ctx.lineTo(x + radius, y + height);
            ctx.quadraticCurveTo(x, y + height, x, y + height - radius);
            ctx.lineTo(x, y + radius);
            ctx.quadraticCurveTo(x, y, x + radius, y);
            ctx.closePath();
            if (fill) {
                ctx.fill();
            }
            if (stroke) {
                ctx.stroke();
            }
        }

        // 노트 판정 허용 오차 가져오기 함수
        function getJudgmentTolerance(note) {
            // 동적으로 스케일링된 허용 오차 사용
            if (note.isLongNote) {
                // 원래 길이 (참조 길이)를 사용하여 올바른 스케일링된 허용 오차에 매핑
                if (note.originalLength === REFERENCE_LONG_NOTE_LENGTHS[0]) { // 2배 길이
                    return LONG_NOTE_TOLERANCE_2X;
                } else if (note.originalLength === REFERENCE_LONG_NOTE_LENGTHS[1]) { // 3배 길이
                    return LONG_NOTE_TOLERANCE_3X;
                } else if (note.originalLength === REFERENCE_LONG_NOTE_LENGTHS[2]) { // 4배 길이
                    return LONG_NOTE_TOLERANCE_4X;
                }
            }
            return REGULAR_NOTE_TOLERANCE;
        }

        // 레인이 활성 노트에 의해 막혀 있는지 확인하는 헬퍼 함수
        function isLaneBlocked(checkLaneIndex, potentialNewNoteLength) {
            // 새 노트는 y = -potentialNewNoteLength에서 생성됨
            const newNoteSpawnTop = -potentialNewNoteLength;
            const newNoteSpawnBottom = 0; // 새 노트의 머리가 y=0에 있을 때의 노트 하단

            for (let i = 0; i < notes.length; i++) {
                const existingNote = notes[i];
                if (existingNote.lane === checkLaneIndex) {
                    const existingNoteTop = existingNote.y;
                    const existingNoteBottom = existingNote.y + existingNote.length;

                    // 수직 중첩 확인
                    // 새 노트의 하단(생성될 때)이 기존 노트의 상단보다 아래에 있고
                    // 새 노트의 상단(생성될 때)이 기존 노트의 하단보다 위에 있으면
                    // 이는 생성 시 중첩됨을 의미
                    if (newNoteSpawnBottom > existingNoteTop && newNoteSpawnTop < existingNoteBottom) {
                        return true; // 중첩 감지, 레인이 막힘
                    }
                }
            }
            return false; // 중첩 없음, 레인이 막히지 않음
        }

        // 게임 루프
        function gameLoop(currentTime) {
            if (!gameRunning || isPaused) { // 게임이 실행 중이 아니거나 일시정지된 경우 중지
                Tone.Transport.stop(); // 게임이 실행 중이 아니면 오디오가 중지되도록 보장
                return;
            }

            // 캔버스 지우기
            ctx.clearRect(0, 0, canvas.width, canvas.height); // 실제 캔버스 크기 사용

            // 레인 그리기
            for (let i = 0; i < REFERENCE_LANE_COUNT; i++) {
                ctx.fillStyle = `rgba(45, 55, 72, 0.5)`;
                ctx.fillRect(i * LANE_SPACING, 0, LANE_SPACING, canvas.height); // 동적 LANE_SPACING 및 canvas.height 사용
            }

            // 히트 존 버튼 그리기
            for (let i = 0; i < REFERENCE_LANE_COUNT; i++) {
                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                const baseColor = 'rgba(100, 100, 100, 0.7)';
                const topColor = pressedKeys[i] ? PRESSED_DARKER_COLOR_TOP : baseColor;
                const bottomColor = pressedKeys[i] ? PRESSED_DARKER_COLOR_BOTTOM : '#333';

                const gradient = ctx.createLinearGradient(i * LANE_SPACING, HIT_ZONE_Y, i * LANE_SPACING, HIT_ZONE_Y + NOTE_SIZE);
                gradient.addColorStop(0, topColor);
                gradient.addColorStop(1, bottomColor);

                ctx.fillStyle = gradient;
                ctx.strokeStyle = '#cbd5e0';
                ctx.lineWidth = 2;
                roundRect(ctx, i * LANE_SPACING + (LANE_SPACING - NOTE_SIZE) / 2, HIT_ZONE_Y, NOTE_SIZE, NOTE_SIZE, CORNER_RADIUS, true, true);
                ctx.restore();

                // 버튼에 키 라벨 그리기
                ctx.fillStyle = 'white';
                ctx.font = `bold ${NOTE_SIZE * 0.22}px Inter`; // 노트 크기에 비례하여 글꼴 크기 스케일링
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const keyText = LANE_KEYS[i];
                ctx.fillText(keyText, i * LANE_SPACING + LANE_SPACING / 2, HIT_ZONE_Y + NOTE_SIZE / 2);
            }

            // 새 노트 생성
            const currentNoteSpawnInterval = DIFFICULTY_SETTINGS[currentDifficulty].noteSpawnInterval;
            if (currentTime - lastNoteTime > currentNoteSpawnInterval) {
                let lane;
                let attempts = 0;
                const MAX_SPAWN_ATTEMPTS = REFERENCE_LANE_COUNT * 2;
                let newNoteVisualLength;
                let isLong;
                let originalNoteLengthReference; // 허용 오차 매핑을 위한 참조 길이 저장

                do {
                    lane = Math.floor(Math.random() * REFERENCE_LANE_COUNT);
                    isLong = Math.random() < LONG_NOTE_CHANCE;
                    
                    if (currentDifficulty === 'impossible') {
                        isLong = false; // 불가능 모드에서는 롱 노트 생성 안 함
                    }

                    newNoteVisualLength = NOTE_SIZE; // 일반 노트의 기본값
                    originalNoteLengthReference = REFERENCE_NOTE_SIZE; // 일반 노트의 기본값
                    if (isLong) {
                        const randomIndex = Math.floor(Math.random() * LONG_NOTE_LENGTHS_DYNAMIC.length);
                        newNoteVisualLength = LONG_NOTE_LENGTHS_DYNAMIC[randomIndex];
                        originalNoteLengthReference = REFERENCE_LONG_NOTE_LENGTHS[randomIndex]; // 원래 참조 길이 저장
                    }

                    attempts++;
                    if (attempts > MAX_SPAWN_ATTEMPTS) {
                        lastNoteTime = currentTime;
                        break;
                    }
                } while (isLaneBlocked(lane, newNoteVisualLength));

                if (attempts <= MAX_SPAWN_ATTEMPTS) {
                    let newNote = {
                        x: lane * LANE_SPACING + (LANE_SPACING - NOTE_WIDTH) / 2,
                        y: -newNoteVisualLength, // 캔버스 위에서 시작, 노트의 전체 길이에 맞춰 조정
                        lane: lane,
                        color: LANE_COLORS[lane],
                        length: newNoteVisualLength,
                        isLongNote: isLong,
                        isHeld: false,
                        hasBeenHit: false,
                        lastHoldScoreTime: 0,
                        originalLength: originalNoteLengthReference // 허용 오차 계산을 위한 원래 참조 길이 저장
                    };
                    notes.push(newNote);
                }
                lastNoteTime = currentTime;
            }

            let nextNotes = [];
            const currentNoteSpeed = DIFFICULTY_SETTINGS[currentDifficulty].noteSpeed * (canvas.height / REFERENCE_CANVAS_HEIGHT_FOR_SCALING); // 속도 스케일링

            for (let i = 0; i < notes.length; i++) {
                let note = notes[i];
                note.y += currentNoteSpeed;

                if (note.isLongNote && note.isHeld && note.hasBeenHit) {
                    if (currentTime - note.lastHoldScoreTime > LONG_NOTE_HOLD_TICK_INTERVAL) {
                        score += LONG_NOTE_HOLD_SCORE_PER_TICK;
                        combo += LONG_NOTE_HOLD_COMBO_PER_TICK;
                        if (combo > maxCombo) { maxCombo = combo; }
                        document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                        document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;
                        if (combo > 0 && combo % 50 === 0) { displayComboPopup(combo); }
                        note.lastHoldScoreTime = currentTime;
                    }
                }

                ctx.save();
                ctx.shadowColor = 'rgba(0, 0, 0, 0.5)';
                ctx.shadowBlur = 5;
                ctx.shadowOffsetX = 2;
                ctx.shadowOffsetY = 2;

                const gradient = ctx.createLinearGradient(note.x, note.y, note.x, note.y + note.length);
                gradient.addColorStop(0, note.color);
                if (note.isLongNote && note.isHeld) {
                    gradient.addColorStop(0.5, 'rgba(255, 255, 255, 0.2)');
                    gradient.addColorStop(1, '#333');
                } else {
                    gradient.addColorStop(1, '#333');
                }

                ctx.fillStyle = gradient;
                if (note.isLongNote && note.isHeld) {
                    ctx.strokeStyle = '#fff';
                    ctx.lineWidth = 3;
                    ctx.filter = 'drop-shadow(0 0 8px rgba(255, 255, 255, 0.8))';
                } else {
                    ctx.strokeStyle = '#e2e8f0';
                    ctx.lineWidth = 1.5;
                    ctx.filter = 'none';
                }
                roundRect(ctx, note.x, note.y, NOTE_WIDTH, note.length, CORNER_RADIUS, true, true);
                ctx.restore();

                ctx.fillStyle = 'white';
                ctx.font = `bold ${NOTE_SIZE * 0.22}px Inter`; // 글꼴 크기 스케일링
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                const keyText = LANE_KEYS[note.lane];
                ctx.fillText(keyText, note.x + NOTE_WIDTH / 2, note.y + NOTE_SIZE / 2);

                if (note.isLongNote) {
                    ctx.save();
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.8)';
                    ctx.beginPath();
                    ctx.arc(note.x + NOTE_WIDTH / 2, note.y + note.length - (CORNER_RADIUS / 2), CORNER_RADIUS / 2, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.restore();
                }

                const currentJudgementTolerance = getJudgmentTolerance(note);
                let shouldRemove = false;

                // 일반 노트가 화면 밖으로 나가면 미스
                if (!note.isLongNote && note.y > canvas.height) {
                    health = Math.max(0, health - HEALTH_ON_MISS);
                    score = Math.max(0, score - SCORE_PENALTIES_ON_EMPTY_PRESS[currentDifficulty]); // 난이도별 페널티 적용
                    document.getElementById('healthDisplay').textContent = `체력: ${health}`;
                    document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                    combo = 0;
                    document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;
                    shouldRemove = true;
                    if (health <= 0) { endGame(); return; }
                }
                // 롱 노트의 머리가 히트 존을 지나쳤는데 히트되지 않은 경우 (초기 미스)
                else if (note.isLongNote && !note.hasBeenHit && note.y > HIT_ZONE_Y + currentJudgementTolerance) {
                    health = Math.max(0, health - HEALTH_ON_MISS);
                    score = Math.max(0, score - SCORE_PENALTIES_ON_EMPTY_PRESS[currentDifficulty]); // 난이도별 페널티 적용
                    document.getElementById('healthDisplay').textContent = `체력: ${health}`;
                    document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                    combo = 0;
                    document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;
                    shouldRemove = true;
                    if (health <= 0) { endGame(); return; }
                }
                // 롱 노트가 히트되었지만 꼬리가 완전히 화면 밖으로 나간 경우 (정리)
                else if (note.isLongNote && note.hasBeenHit && note.y > canvas.height) {
                    shouldRemove = true;
                }

                if (!shouldRemove) {
                    nextNotes.push(note);
                }
            }
            notes = nextNotes;

            animationFrameId = requestAnimationFrame(gameLoop);
        }

        // ESC 키와 같은 전역 키 처리를 위한 함수
        function handleGlobalKeyPress(event) {
            if (event.key === 'Escape') {
                if (gameRunning) { // 게임이 현재 실행 중일 때만 일시정지/재개
                    if (!isPaused) {
                        pauseGame();
                    } else {
                        // 이미 일시정지된 경우, ESC를 다시 누르면 재개
                        resumeGame();
                    }
                }
            }
        }

        // 게임 특정 키 입력 (D, F, J, K) 처리 함수
        function handleKeyPress(event) {
            if (!gameRunning || isPaused) return; // 게임이 실행 중이 아니거나 일시정지된 경우 입력 무시

            const pressedKey = event.key.toLowerCase();
            const laneIndex = KEY_MAP[pressedKey];

            if (laneIndex !== undefined) {
                if (pressedKeys[laneIndex]) return; // 이미 눌린 키는 무시
                pressedKeys[laneIndex] = true;

                let hit = false;
                let noteFound = null;

                for (let i = 0; i < notes.length; i++) {
                    const note = notes[i];
                    const currentJudgementTolerance = getJudgmentTolerance(note);

                    if (note.lane === laneIndex &&
                        note.y + NOTE_SIZE >= HIT_ZONE_Y - currentJudgementTolerance &&
                        note.y <= HIT_ZONE_Y + HIT_ZONE_HEIGHT + currentJudgementTolerance) {
                        
                        if (!note.isLongNote || (note.isLongNote && !note.hasBeenHit)) {
                            noteFound = note;
                            break;
                        }
                    }
                    else if (note.isLongNote && note.hasBeenHit && note.lane === laneIndex &&
                             note.y + note.length > HIT_ZONE_Y + HIT_ZONE_HEIGHT - currentJudgementTolerance) {
                        noteFound = note;
                        break;
                    }
                }

                if (noteFound) {
                    if (noteFound.isLongNote) {
                        if (!noteFound.hasBeenHit) {
                            noteFound.hasBeenHit = true;
                            noteFound.isHeld = true;
                            noteFound.lastHoldScoreTime = performance.now();
                            score += 100;
                            combo++;
                            if (combo > maxCombo) { maxCombo = combo; }
                            document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                            document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;
                            if (combo > 0 && combo % 50 === 0) { displayComboPopup(combo); }
                            synth.triggerAttackRelease("C5", "8n");
                            hit = true;
                        }
                        else {
                            noteFound.isHeld = true;
                            hit = true;
                        }
                    } else {
                        score += 100;
                        combo++;
                        if (combo > maxCombo) { maxCombo = combo; }
                        document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                        document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;
                        if (combo > 0 && combo % 50 === 0) { displayComboPopup(combo); }
                        notes.splice(notes.indexOf(noteFound), 1);
                        synth.triggerAttackRelease("C5", "8n");
                        hit = true;
                    }
                }

                // 노트가 히트되지 않은 경우 (빈 입력)
                if (!hit) {
                    score = Math.max(0, score - SCORE_PENALTIES_ON_EMPTY_PRESS[currentDifficulty]); // 난이도별 페널티만큼 점수 감소
                    document.getElementById('scoreDisplay').textContent = `점수: ${score}`; // 점수 디스플레이 업데이트
                    combo = 0; // 콤보 초기화
                    document.getElementById('comboDisplay').textContent = `콤보: ${combo}`; // 콤보 디스플레이 업데이트
                    synth.triggerAttackRelease("C3", "16n"); // 피드백을 위해 낮은 톤 재생
                }
            }
        }

        // 키 떼기 처리 함수
        function handleKeyRelease(event) {
            if (!gameRunning || isPaused) return; // 게임이 실행 중이 아니거나 일시정지된 경우 입력 무시

            const releasedKey = event.key.toLowerCase();
            const laneIndex = KEY_MAP[releasedKey];

            if (laneIndex !== undefined) {
                pressedKeys[laneIndex] = false;

                let heldLongNote = null;
                for (let i = 0; i < notes.length; i++) {
                    const note = notes[i];
                    if (note.lane === laneIndex && note.isLongNote && note.hasBeenHit && note.isHeld) {
                        heldLongNote = note;
                        break;
                    }
                }

                if (heldLongNote) {
                    heldLongNote.isHeld = false;

                    const currentJudgementTolerance = getJudgmentTolerance(heldLongNote);

                    const tailHitZoneY = HIT_ZONE_Y + HIT_ZONE_HEIGHT;
                    const noteTailY = heldLongNote.y + heldLongNote.length;

                    if (noteTailY >= tailHitZoneY - currentJudgementTolerance) {
                        score += LONG_NOTE_HOLD_SCORE;
                        document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                        const indexToRemove = notes.indexOf(heldLongNote);
                        if (indexToRemove > -1) {
                            notes.splice(indexToRemove, 1);
                        }
                    } else {
                        // 일찍 떼기 (미스)
                        health = Math.max(0, health - HEALTH_ON_MISS);
                        score = Math.max(0, score - SCORE_PENALTIES_ON_EMPTY_PRESS[currentDifficulty]); // 난이도별 페널티 적용
                        document.getElementById('healthDisplay').textContent = `체력: ${health}`;
                        document.getElementById('scoreDisplay').textContent = `점수: ${score}`;
                        combo = 0;
                        document.getElementById('comboDisplay').textContent = `콤보: ${combo}`;
                        synth.triggerAttackRelease("C3", "16n");
                        const indexToRemove = notes.indexOf(heldLongNote);
                        if (indexToRemove > -1) {
                            notes.splice(indexToRemove, 1);
                        }
                        if (health <= 0) { endGame(); }
                    }
                }
            }
        }

        // 게임 일시정지 함수
        function pauseGame() {
            isPaused = true;
            currentPauseStartTime = performance.now(); // 일시정지 시작 시간 기록
            cancelAnimationFrame(animationFrameId); // 게임 루프 중지
            Tone.Transport.pause(); // 오디오 일시정지
            clearTimeout(gameTimeoutId); // 게임 종료 타이머 지우기

            pauseMenuElement.style.display = 'flex'; // 일시정지 메뉴 표시
            document.getElementById('startButton').style.display = 'none'; // 시작 버튼 숨기기
            document.querySelector('.difficulty-selection').style.display = 'none'; // 난이도 버튼 숨기기
        }

        // 게임 재개 함수
        function resumeGame() {
            if (!isPaused) return; // 실제로 일시정지된 경우에만 재개

            isPaused = false;
            totalPausedTime += performance.now() - currentPauseStartTime; // 총 일시정지 시간에 추가

            animationFrameId = requestAnimationFrame(gameLoop); // 게임 루프 재개
            Tone.Transport.start(); // 오디오 재개

            // 남은 게임 시간 재계산 및 새 타임아웃 설정
            const timeElapsedSinceGameStart = performance.now() - gameStartTime - totalPausedTime;
            const remainingGameTime = GAME_DURATION_MS - timeElapsedSinceGameStart;
            gameTimeoutId = setTimeout(endGame, remainingGameTime);

            pauseMenuElement.style.display = 'none'; // 일시정지 메뉴 숨기기
            // 필요한 경우 게임 요소 표시 (단, 보통 startGame/endGame에 의해 숨겨짐)
        }

        // 게임 종료 함수
        function endGame() {
            // 이 함수는 주로 최종 게임 오버 메시지를 표시하고 새 게임을 준비하기 위해 상태를 초기화하는 역할
            if (!gameRunning) return; // 게임이 실제로 실행 중인 경우에만 진행

            // 게임 루프 및 오디오 중지
            gameRunning = false;
            isPaused = false;
            cancelAnimationFrame(animationFrameId);
            Tone.Transport.stop();
            bgmPart.stop(); // 시퀀스 명시적으로 중지
            clearTimeout(gameTimeoutId);

            // 표시될 수 있는 모든 게임 관련 UI 요소 숨기기
            pauseMenuElement.style.display = 'none';
            countdownDisplayElement.style.display = 'none';
            comboPopup.style.opacity = '0';

            // 게임 오버 메시지 표시
            showMessageBox(`게임 종료!\n최종 점수: ${score}점\n최고 콤보: ${maxCombo}콤보\n체력: ${health}\n난이도: ${DIFFICULTY_SETTINGS[currentDifficulty].name}`, () => {
                // 메시지 박스에서 사용자가 확인을 클릭한 후 게임 상태 초기화
                resetGameState();
            });
        }
    </script>
</body>
</html>
